# [935. Knight Dialer](https://leetcode.com/problems/knight-dialer/description/)

To solve this problem, we need to determine the number of distinct phone numbers of length `n` that can be generated by a knight on a numeric keypad. The knight moves according to chess rules, which means it can jump in an L-shape to another key on the pad.

### Keypad Layout:

The numeric keypad can be visualized as follows:

```
1 2 3
4 5 6
7 8 9
  0
```

The knight has specific valid moves from each key:
- From `1`: it can move to `6`, `8`.
- From `2`: it can move to `7`, `9`.
- From `3`: it can move to `4`, `8`.
- From `4`: it can move to `3`, `9`, `0`.
- From `5`: it cannot move anywhere.
- From `6`: it can move to `1`, `7`, `0`.
- From `7`: it can move to `2`, `6`.
- From `8`: it can move to `1`, `3`.
- From `9`: it can move to `2`, `4`.
- From `0`: it can move to `4`, `6`.

### Dynamic Programming Approach:

We'll use dynamic programming (DP) to solve this problem. We'll create a DP table `dp` where `dp[i][j]` represents the number of distinct phone numbers of length `i` ending on digit `j`.

**Transition:**
- For each step from `1` to `n`, for each digit `j`, we calculate how many numbers of length `i` can be formed by summing up all possible moves from previous digits.

### Base Case:
- When `n = 1`, each key is itself a valid number, so for each digit, `dp[1][digit] = 1`.

### Recurrence:
- For `i > 1`, `dp[i][digit] = sum(dp[i-1][k])` for each valid `k` that can move to `digit`.

### Final Answer:
- The result is the sum of `dp[n][j]` for all digits `j`.

Hereâ€™s the Python code implementing this approach:

```python
class Solution:
    def knightDialer(self, n: int) -> int:
        MOD = 10**9 + 7
        
        # Moves dictionary where key is digit and value is list of digits it can move to
        moves = {
            0: [4, 6],
            1: [6, 8],
            2: [7, 9],
            3: [4, 8],
            4: [3, 9, 0],
            5: [],  # 5 cannot move anywhere
            6: [1, 7, 0],
            7: [2, 6],
            8: [1, 3],
            9: [2, 4]
        }
        
        # Initialize DP table
        dp = [[0] * 10 for _ in range(n+1)]
        
        # Base case: length 1
        for digit in range(10):
            dp[1][digit] = 1
        
        # Fill DP table
        for i in range(2, n+1):
            for digit in range(10):
                dp[i][digit] = sum(dp[i-1][prev] for prev in moves[digit]) % MOD
        
        # Answer is the sum of all numbers of length n
        return sum(dp[n][digit] for digit in range(10)) % MOD
```

### Explanation:
- **MOD:** We use modulo `10^9 + 7` to ensure the numbers don't get too large.
- **moves dictionary:** It stores the valid knight moves from each digit.
- **dp table:** We construct this table iteratively, using the number of valid ways to end on each digit after `i-1` steps to calculate the number of ways to end on each digit after `i` steps.
- **Final sum:** The sum of `dp[n][digit]` for all digits gives us the total number of valid phone numbers of length `n`.

### Complexity:
- **Time Complexity:** O(n * 10) = O(n) since we iterate over each digit for every step from 1 to `n`.
- **Space Complexity:** O(n * 10) = O(n), as we store results for each length up to `n` for each digit.

This solution is efficient and works well within the given constraints.
