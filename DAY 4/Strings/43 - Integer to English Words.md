# [273. Integer to English Words](https://leetcode.com/problems/integer-to-english-words/description/)
[Leetcode Solution](https://leetcode.com/problems/integer-to-english-words/solutions/5545280/easy-solution-challenge-day-4-revisewitharsh)

Given a non-negative integer `num`, you need to convert it into its English words representation. The number can range from 0 to 2^31 - 1 (i.e., 2,147,483,647). The output should be the number expressed in words, with proper handling of large numbers and English grammatical rules.

## Intuition

To solve the problem, you need to break down the number into smaller, manageable chunks. This involves:
1. **Handling small numbers**: Convert numbers less than 20 directly into words.
2. **Handling tens**: Convert numbers from 20 to 99 by combining the appropriate "tens" and "ones" words.
3. **Handling hundreds and thousands**: Convert numbers in terms of hundreds, thousands, millions, and billions, appending appropriate suffixes.

## Approach

1. **Define Word Lists**:
   - `to19`: List for numbers from 1 to 19.
   - `tens`: List for multiples of ten from 20 to 90.

2. **Recursive Function `words(n)`**:
   - **Base Cases**:
     - If `n` is less than 20, return the corresponding words from `to19`.
     - If `n` is less than 100, handle tens and units.
     - If `n` is less than 1000, handle hundreds and the rest recursively.
   - **Handling Larger Numbers**:
     - For numbers in thousands, millions, and billions, break down the number using powers of 1000 and append appropriate suffixes.

3. **Combine Results**:
   - Join the words generated by the `words(n)` function with spaces.
   - Handle the special case where the number is 0, returning "Zero".

## Code

Here's the Python code that implements the above approach:

```python
class Solution(object):
    def numberToWords(self, num):
        # Word lists for small numbers
        to19 = 'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve ' \
            'Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.split()
        tens = 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.split()
        
        def words(n):
            # Base cases
            if n < 20:
                return to19[n-1:n]
            if n < 100:
                return [tens[n // 10 - 2]] + words(n % 10)
            if n < 1000:
                return [to19[n // 100 - 1]] + ['Hundred'] + words(n % 100)
            
            # Handling thousands, millions, and billions
            for p, w in enumerate(('Thousand', 'Million', 'Billion'), 1):
                if n < 1000 ** (p + 1):
                    return words(n // 1000 ** p) + [w] + words(n % 1000 ** p)
        
        return ' '.join(words(num)) or 'Zero'
```

## Complexity

- **Time Complexity**: \(O(\log_{1000}(\text{num}))\)
  - The recursive approach breaks down the number into smaller chunks. Each recursion handles one of the components (hundreds, thousands, etc.), and the depth of recursion is proportional to the logarithm of the number base 1000.

- **Space Complexity**: \(O(\log_{1000}(\text{num}))\)
  - Due to recursion depth and space required to store words in the list.

This implementation effectively converts a number to its English words representation by breaking the problem into manageable pieces and using recursion to handle larger numbers.
