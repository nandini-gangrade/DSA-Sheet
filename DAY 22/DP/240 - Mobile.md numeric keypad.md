# [Mobile numeric keypad](https://www.geeksforgeeks.org/problems/mobile-numeric-keypad5456/1)

### Problem Breakdown:
The task is to find the number of unique sequences of length `n` that can be generated by pressing keys on a numeric keypad with restrictions on allowable moves. Specifically, from any key, you can press the current key or move to an adjacent key (up, down, left, right). Diagonal moves or moving to `*` or `#` is not allowed.

### Approach:
1. **Keypad Layout**:
   The keypad is laid out as follows:
   ```
   1 2 3
   4 5 6
   7 8 9
     0
   ```

2. **Allowed Moves**:
   - Each digit on the keypad has specific valid moves to adjacent keys.
   - For example:
     - From `5`, you can move to `2`, `4`, `6`, `8`, or stay at `5`.
     - From `1`, you can move to `2`, `4`, or stay at `1`.

3. **Dynamic Programming (DP) Approach**:
   - Let `dp[j]` represent the number of sequences of length `n` that end at digit `j`.
   - At each step, update the DP table for the next length based on allowed moves for each digit.
   
4. **Transitions**:
   - For each step, create a new DP table (`curr`) and fill it based on the valid moves from the previous DP table (`dp`).
   - For each digit `j`, the number of sequences ending at `j` is the sum of all sequences that could move to `j`.

5. **Final Count**:
   - Sum the counts in `dp` after processing all digits for sequences of length `n`.

### Code Implementation:

```cpp
long long getCount(int n) {
    // DP table to store number of sequences for each digit (0-9)
    vector<long long int> dp(10, 1);  // Initially, for n=1, all digits can be used exactly once
    
    // Keypad adjacency list, indicating where we can move from each digit
    vector<vector<int>> vec = {
        {0, 8},         // 0 can go to 0 or 8
        {1, 2, 4},      // 1 can go to 1, 2, 4
        {1, 2, 3, 5},   // 2 can go to 1, 2, 3, 5
        {2, 3, 6},      // 3 can go to 2, 3, 6
        {1, 4, 5, 7},   // 4 can go to 1, 4, 5, 7
        {2, 4, 5, 6, 8},// 5 can go to 2, 4, 5, 6, 8
        {3, 5, 6, 9},   // 6 can go to 3, 5, 6, 9
        {4, 7, 8},      // 7 can go to 4, 7, 8
        {0, 5, 7, 8, 9},// 8 can go to 0, 5, 7, 8, 9
        {6, 8, 9}       // 9 can go to 6, 8, 9
    };

    // Start from n=2 to n since dp is already initialized for n=1
    for (int i = 2; i <= n; ++i) {
        vector<long long int> curr(10, 0);  // Temporary table for sequences of length i
        for (int j = 0; j < 10; ++j) {
            for (int prev : vec[j]) {
                curr[j] += dp[prev];  // Add all possible previous sequences leading to current j
            }
        }
        dp = curr;  // Update dp for the next iteration
    }
    
    // Sum up all valid sequences for each digit
    long long sum = 0;
    for (int i = 0; i < 10; ++i) {
        sum += dp[i];
    }
    return sum;
}
```

### Explanation:

1. **Initialization**:
   - The `dp` array is initialized with `1`s because for `n = 1`, every digit from `0` to `9` can form a sequence of length `1`.

2. **Keypad Transitions**:
   - The `vec` array represents all valid moves for each digit on the keypad.

3. **Dynamic Programming Transition**:
   - For each digit `j`, we calculate the possible sequences that can end at `j` by summing up the number of sequences that can move to `j` from its neighboring digits (based on `vec`).

4. **Final Sum**:
   - After processing all `n` steps, the `dp` array contains the number of valid sequences of length `n` that end at each digit. Summing these gives the total number of valid sequences.

### Time and Space Complexity:

- **Time Complexity**: O(n), since we iterate through the digits `0` to `9` for each step from `2` to `n` (a constant number of operations for each step).
- **Space Complexity**: O(1) or O(10), since we only need to store the current and previous DP arrays.

### Example:

1. **Input**: `n = 1`
   - Output: `10` (because all digits `0-9` can form sequences of length `1`)

2. **Input**: `n = 2`
   - Output: `36` (because there are 36 valid sequences of length `2` based on the allowed moves on the keypad)

This solution is efficient and works within the given constraints of `1 <= n <= 25`.
